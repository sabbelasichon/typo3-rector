--- /dev/null
+++ ../src/NodeManipulator/ClassDependencyManipulator.php
@@ -3,11 +3,14 @@
 declare (strict_types=1);
 namespace Rector\NodeManipulator;
 
+use PhpParser\Node\Arg;
 use PhpParser\Node\Expr\Assign;
 use PhpParser\Node\Expr\StaticCall;
+use PhpParser\Node\Expr\Variable;
 use PhpParser\Node\Name;
 use PhpParser\Node\Stmt;
 use PhpParser\Node\Stmt\Class_;
+use PhpParser\Node\Stmt\ClassLike;
 use PhpParser\Node\Stmt\ClassMethod;
 use PhpParser\Node\Stmt\Expression;
 use PhpParser\Node\Stmt\Property;
@@ -17,6 +20,7 @@
 use Rector\NodeAnalyzer\PropertyPresenceChecker;
 use Rector\NodeNameResolver\NodeNameResolver;
 use Rector\Php\PhpVersionProvider;
+use Rector\PhpParser\AstResolver;
 use Rector\PhpParser\Node\NodeFactory;
 use Rector\PostRector\ValueObject\PropertyMetadata;
 use Rector\Reflection\ReflectionResolver;
@@ -73,7 +77,12 @@
      * @var \Rector\Reflection\ReflectionResolver
      */
     private $reflectionResolver;
-    public function __construct(\Rector\NodeManipulator\ClassInsertManipulator $classInsertManipulator, \Rector\NodeManipulator\ClassMethodAssignManipulator $classMethodAssignManipulator, NodeFactory $nodeFactory, \Rector\NodeManipulator\StmtsManipulator $stmtsManipulator, PhpVersionProvider $phpVersionProvider, PropertyPresenceChecker $propertyPresenceChecker, NodeNameResolver $nodeNameResolver, AutowiredClassMethodOrPropertyAnalyzer $autowiredClassMethodOrPropertyAnalyzer, ReflectionResolver $reflectionResolver)
+    /**
+     * @readonly
+     * @var \Rector\PhpParser\AstResolver
+     */
+    private $astResolver;
+    public function __construct(\Rector\NodeManipulator\ClassInsertManipulator $classInsertManipulator, \Rector\NodeManipulator\ClassMethodAssignManipulator $classMethodAssignManipulator, NodeFactory $nodeFactory, \Rector\NodeManipulator\StmtsManipulator $stmtsManipulator, PhpVersionProvider $phpVersionProvider, PropertyPresenceChecker $propertyPresenceChecker, NodeNameResolver $nodeNameResolver, AutowiredClassMethodOrPropertyAnalyzer $autowiredClassMethodOrPropertyAnalyzer, ReflectionResolver $reflectionResolver, AstResolver $astResolver)
     {
         $this->classInsertManipulator = $classInsertManipulator;
         $this->classMethodAssignManipulator = $classMethodAssignManipulator;
@@ -84,21 +93,33 @@
         $this->nodeNameResolver = $nodeNameResolver;
         $this->autowiredClassMethodOrPropertyAnalyzer = $autowiredClassMethodOrPropertyAnalyzer;
         $this->reflectionResolver = $reflectionResolver;
+        $this->astResolver = $astResolver;
     }
     public function addConstructorDependency(Class_ $class, PropertyMetadata $propertyMetadata) : void
     {
+        // already has property as dependency? skip it
         if ($this->hasClassPropertyAndDependency($class, $propertyMetadata)) {
             return;
         }
-        if (!$this->phpVersionProvider->isAtLeastPhpVersion(PhpVersionFeature::PROPERTY_PROMOTION)) {
+        // special case for Symfony @required
+        $autowireClassMethod = $this->autowiredClassMethodOrPropertyAnalyzer->matchAutowiredMethodInClass($class);
+        if (!$this->phpVersionProvider->isAtLeastPhpVersion(PhpVersionFeature::PROPERTY_PROMOTION) || $autowireClassMethod instanceof ClassMethod) {
             $this->classInsertManipulator->addPropertyToClass($class, $propertyMetadata->getName(), $propertyMetadata->getType());
         }
+        // in case of existing autowire method, re-use it
+        if ($autowireClassMethod instanceof ClassMethod) {
+            $assign = $this->nodeFactory->createPropertyAssignment($propertyMetadata->getName());
+            $this->classMethodAssignManipulator->addParameterAndAssignToMethod($autowireClassMethod, $propertyMetadata->getName(), $propertyMetadata->getType(), $assign);
+            return;
+        }
+        $constructClassMethod = $this->resolveConstruct($class);
+        // add PHP 8.0 promoted property
         if ($this->shouldAddPromotedProperty($class, $propertyMetadata)) {
-            $this->addPromotedProperty($class, $propertyMetadata);
-        } else {
-            $assign = $this->nodeFactory->createPropertyAssignment($propertyMetadata->getName());
-            $this->addConstructorDependencyWithCustomAssign($class, $propertyMetadata->getName(), $propertyMetadata->getType(), $assign);
+            $this->addPromotedProperty($class, $propertyMetadata, $constructClassMethod);
+            return;
         }
+        $assign = $this->nodeFactory->createPropertyAssignment($propertyMetadata->getName());
+        $this->addConstructorDependencyWithCustomAssign($class, $propertyMetadata->getName(), $propertyMetadata->getType(), $assign);
     }
     /**
      * @api doctrine
@@ -105,15 +126,25 @@
      */
     public function addConstructorDependencyWithCustomAssign(Class_ $class, string $name, ?Type $type, Assign $assign) : void
     {
-        /** @var ClassMethod|null $constructorMethod */
-        $constructorMethod = $class->getMethod(MethodName::CONSTRUCT);
-        if ($constructorMethod instanceof ClassMethod) {
-            $this->classMethodAssignManipulator->addParameterAndAssignToMethod($constructorMethod, $name, $type, $assign);
+        /** @var ClassMethod|null $constructClassMethod */
+        $constructClassMethod = $this->resolveConstruct($class);
+        if ($constructClassMethod instanceof ClassMethod) {
+            if (!$class->getMethod(MethodName::CONSTRUCT) instanceof ClassMethod) {
+                $parentArgs = [];
+                foreach ($constructClassMethod->params as $originalParam) {
+                    $parentArgs[] = new Arg(new Variable((string) $this->nodeNameResolver->getName($originalParam->var)));
+                }
+                $constructClassMethod->stmts = [new Expression(new StaticCall(new Name(ObjectReference::PARENT), MethodName::CONSTRUCT, $parentArgs))];
+                $this->classInsertManipulator->addAsFirstMethod($class, $constructClassMethod);
+                $this->classMethodAssignManipulator->addParameterAndAssignToMethod($constructClassMethod, $name, $type, $assign);
+            } else {
+                $this->classMethodAssignManipulator->addParameterAndAssignToMethod($constructClassMethod, $name, $type, $assign);
+            }
             return;
         }
-        $constructorMethod = $this->nodeFactory->createPublicMethod(MethodName::CONSTRUCT);
-        $this->classMethodAssignManipulator->addParameterAndAssignToMethod($constructorMethod, $name, $type, $assign);
-        $this->classInsertManipulator->addAsFirstMethod($class, $constructorMethod);
+        $constructClassMethod = $this->nodeFactory->createPublicMethod(MethodName::CONSTRUCT);
+        $this->classMethodAssignManipulator->addParameterAndAssignToMethod($constructClassMethod, $name, $type, $assign);
+        $this->classInsertManipulator->addAsFirstMethod($class, $constructClassMethod);
     }
     /**
      * @api doctrine
@@ -139,9 +170,46 @@
         }
         $classMethod->stmts = \array_merge($stmts, (array) $classMethod->stmts);
     }
-    private function addPromotedProperty(Class_ $class, PropertyMetadata $propertyMetadata) : void
+    private function resolveConstruct(Class_ $class) : ?ClassMethod
     {
-        $constructClassMethod = $class->getMethod(MethodName::CONSTRUCT);
+        /** @var ClassMethod|null $constructorMethod */
+        $constructorMethod = $class->getMethod(MethodName::CONSTRUCT);
+        // exists in current class
+        if ($constructorMethod instanceof ClassMethod) {
+            return $constructorMethod;
+        }
+        // lookup parent, found first found (nearest parent constructor to follow)
+        $classReflection = $this->reflectionResolver->resolveClassReflection($class);
+        if (!$classReflection instanceof ClassReflection) {
+            return null;
+        }
+        $ancestors = \array_filter($classReflection->getAncestors(), static fn(ClassReflection $ancestor): bool => $ancestor->getName() !== $classReflection->getName());
+        foreach ($ancestors as $ancestor) {
+            if (!$ancestor->hasNativeMethod(MethodName::CONSTRUCT)) {
+                continue;
+            }
+            $parentClass = $this->astResolver->resolveClassFromClassReflection($ancestor);
+            if (!$parentClass instanceof ClassLike) {
+                continue;
+            }
+            $parentConstructorMethod = $parentClass->getMethod(MethodName::CONSTRUCT);
+            if (!$parentConstructorMethod instanceof ClassMethod) {
+                continue;
+            }
+            if ($parentConstructorMethod->isPrivate()) {
+                // stop, nearest __construct() uses private visibility
+                // which parent::__construct() will cause error
+                break;
+            }
+            $constructorMethod = clone $parentConstructorMethod;
+            // reprint parent method node to avoid invalid tokens
+            $this->nodeFactory->createReprintedNode($constructorMethod);
+            return $constructorMethod;
+        }
+        return null;
+    }
+    private function addPromotedProperty(Class_ $class, PropertyMetadata $propertyMetadata, ?ClassMethod $constructClassMethod) : void
+    {
         $param = $this->nodeFactory->createPromotedPropertyParam($propertyMetadata);
         if ($constructClassMethod instanceof ClassMethod) {
             // parameter is already added
@@ -148,7 +216,18 @@
             if ($this->hasMethodParameter($constructClassMethod, $propertyMetadata->getName())) {
                 return;
             }
-            $constructClassMethod->params[] = $param;
+            // found construct, but only on parent, add to current class
+            if (!$class->getMethod(MethodName::CONSTRUCT) instanceof ClassMethod) {
+                $parentArgs = [];
+                foreach ($constructClassMethod->params as $originalParam) {
+                    $parentArgs[] = new Arg(new Variable((string) $this->nodeNameResolver->getName($originalParam->var)));
+                }
+                $constructClassMethod->params[] = $param;
+                $constructClassMethod->stmts = [new Expression(new StaticCall(new Name(ObjectReference::PARENT), MethodName::CONSTRUCT, $parentArgs))];
+                $this->classInsertManipulator->addAsFirstMethod($class, $constructClassMethod);
+            } else {
+                $constructClassMethod->params[] = $param;
+            }
         } else {
             $constructClassMethod = $this->nodeFactory->createPublicMethod(MethodName::CONSTRUCT);
             $constructClassMethod->params[] = $param;
